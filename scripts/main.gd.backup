extends Control

# Operation mode handlers implemented directly in main script

@onready var matrix_container = $MainPanel/MatrixArea/MatrixContainer
@onready var operation_text = $MainPanel/SidePanel/OperationText
@onready var operation_label = $MainPanel/SidePanel/OperationLabel
@onready var history_panel = $MainPanel/SidePanel/HistoryPanel

var BlockScene = preload("res://scenes/Block.tscn")
var MatrixRowScene = preload("res://scenes/MatrixRow.tscn")

# Constantes para los modos de operaci√≥n
enum OperationMode {
	NONE,       # Modo por defecto (intercambiar filas)
	MULTIPLY,   # Multiplicar una fila por un escalar
	DIVIDE,     # Dividir una fila por un escalar
	ADD_ROWS    # Sumar a una fila un m√∫ltiplo escalar de otra fila
}

# Matriz con color asociado por fila
var matrix_data = [
	{ "values": [1, 2, 3, 4], "color": Color(1, 0.4, 0.4) },     # rojo
	{ "values": [5, 6, 7, 8], "color": Color(1, 0.8, 0.2) },     # amarillo
	{ "values": [9, 10, 11, 12], "color": Color(0.4, 1, 0.4) },  # verde
	{ "values": [13, 14, 15, 16], "color": Color(0.4, 0.6, 1) }  # azul
]

# Variables para controlar la interfaz y las operaciones
var selected_row_index := -1
var current_mode := OperationMode.NONE
var first_row_selected := -1   # Para operaciones que involucran dos filas
var scalar_value := 1.0        # Valor escalar para multiplicaci√≥n/divisi√≥n/suma
var preview_active := false    # Indica si hay una vista previa activa
var preview_data := []         # Datos temporales para la vista previa
var input_mode := false       # Indica si estamos en modo de entrada de n√∫mero
var input_value := ""         # Valor temporal durante la entrada de n√∫mero
var active_preview_tweens := []  # Track active preview animation tweens

func _ready():
	generate_matrix_ui()
	update_operation_display()
	
func _input(event):
	# Manejo de teclas para cambiar modos de operaci√≥n
	if event is InputEventKey and event.pressed:
		# Si estamos en modo de entrada, capturar n√∫meros y procesarlos
		if input_mode:
			match event.keycode:
				KEY_0, KEY_KP_0: 
					input_value += "0"
				KEY_1, KEY_KP_1:
					input_value += "1"
				KEY_2, KEY_KP_2:
					input_value += "2"
				KEY_3, KEY_KP_3:
					input_value += "3"
				KEY_4, KEY_KP_4:
					input_value += "4"
				KEY_5, KEY_KP_5:
					input_value += "5"
				KEY_6, KEY_KP_6:
					input_value += "6"
				KEY_7, KEY_KP_7:
					input_value += "7"
				KEY_8, KEY_KP_8:
					input_value += "8"
				KEY_9, KEY_KP_9:
					input_value += "9"
				KEY_PERIOD, KEY_KP_PERIOD: 
					if not "." in input_value:
						input_value += "."
				KEY_BACKSPACE:
					if input_value.length() > 0:
						input_value = input_value.substr(0, input_value.length() - 1)
				KEY_ENTER, KEY_KP_ENTER:
					# Aplicar el valor ingresado si es v√°lido
					if input_value.length() > 0:
						var new_value = float(input_value)
						if current_mode == OperationMode.DIVIDE and new_value == 0:
							# No permitir divisi√≥n por cero
							new_value = 1.0
						scalar_value = new_value
						input_mode = false
						input_value = ""
						update_operation_display()
						
						# Actualizar la vista previa si est√° activa
						if preview_active and selected_row_index >= 0:
							show_operation_preview()
					else:
						# Si no hay valor, aplicar la operaci√≥n actual
						apply_current_operation()
				KEY_ESCAPE:
					# Cancelar la entrada de n√∫mero y deseleccionar todo
					input_mode = false
					input_value = ""
					reset_operation_mode()
					return
			
			# Actualizar la visualizaci√≥n mientras se escribe
			if input_mode:
				update_operation_display()
				return
		
		# Manejo normal de teclas cuando no estamos en modo de entrada
		match event.keycode:
			KEY_S:  # Modo suma
				set_operation_mode(OperationMode.ADD_ROWS)
			KEY_M:  # Modo multiplicaci√≥n
				set_operation_mode(OperationMode.MULTIPLY)
			KEY_D:  # Modo divisi√≥n
				set_operation_mode(OperationMode.DIVIDE)
			KEY_ESCAPE:  # Cancelar y volver al modo normal
				reset_operation_mode()
			KEY_KP_ADD, KEY_PLUS:  # Aumentar valor escalar
				change_scalar_value(0.5)
			KEY_KP_SUBTRACT, KEY_MINUS:  # Disminuir valor escalar
				change_scalar_value(-0.5)
			KEY_UP:  # Cambiar a la fila anterior
				change_selected_row(-1)
			KEY_DOWN:  # Cambiar a la fila siguiente
				change_selected_row(1)
			KEY_ENTER, KEY_KP_ENTER:  # Confirmar operaci√≥n actual
				apply_current_operation()
			KEY_N:  # Activar modo de entrada num√©rica
				if current_mode in [OperationMode.MULTIPLY, OperationMode.DIVIDE, OperationMode.ADD_ROWS]:
					input_mode = true
					input_value = ""
					update_operation_display()
			_:  # Para cualquier otra tecla, verificar si es un n√∫mero
				# Iniciar modo de entrada con cualquier tecla num√©rica
				if current_mode in [OperationMode.MULTIPLY, OperationMode.DIVIDE, OperationMode.ADD_ROWS]:
					var key_val = OS.get_keycode_string(event.keycode).to_lower()
					if key_val.is_valid_int() or key_val == "0":
						input_mode = true
						input_value = key_val
						update_operation_display()

func change_selected_row(direction: int) -> void:
	var total_rows = matrix_data.size()
	var new_row_index = -1
	
	# Determine the new row index based on current selection and direction
	if selected_row_index == -1:
		# No row currently selected, start from first or last row based on direction
		new_row_index = 0 if direction > 0 else total_rows - 1
	else:
		# Move to next/previous row with wrapping
		new_row_index = (selected_row_index + direction) % total_rows
		if new_row_index < 0:
			new_row_index = total_rows - 1
	
	# Apply the selection to the new row using internal row selection logic
	if new_row_index >= 0 and new_row_index < total_rows:
		_handle_row_selection_internal(new_row_index)

# Funciones para manejar los modos de operaci√≥n
func set_operation_mode(mode: int) -> void:
	# Limpiar cualquier vista previa activa
	clear_operation_preview()
	
	if current_mode == mode:
		reset_operation_mode()
		return
	
	current_mode = OperationMode.values()[mode]
	selected_row_index = -1
	first_row_selected = -1
	scalar_value = 1.0
	update_operation_display()
	
	# Limpiar cualquier selecci√≥n previa
	for i in range(matrix_container.get_child_count()):
		set_row_highlight(i, false)

func reset_operation_mode() -> void:
	# Limpiar cualquier vista previa activa
	clear_operation_preview()
	
	# Resetear modo de entrada num√©rica
	input_mode = false
	input_value = ""
	
	# Limpiar todas las selecciones de filas ANTES de resetear los √≠ndices
	for i in range(matrix_container.get_child_count()):
		set_row_highlight(i, false)
	
	current_mode = OperationMode.NONE
	selected_row_index = -1
	first_row_selected = -1
	scalar_value = 1.0
	update_operation_display()

func change_scalar_value(delta: float) -> void:
	if current_mode in [OperationMode.MULTIPLY, OperationMode.DIVIDE, OperationMode.ADD_ROWS]:
		scalar_value += delta
		# Para divisi√≥n, evitar el valor 0
		if current_mode == OperationMode.DIVIDE:
			scalar_value = max(0.5, scalar_value)  # No permitir valores menores a 0.5 para divisi√≥n
		update_operation_display()
		
		# Si hay una fila seleccionada, actualizar la vista previa con el nuevo valor escalar
		if preview_active and selected_row_index >= 0:
			show_operation_preview()

func update_operation_display() -> void:
	# Handle operation display based on current mode
	match current_mode:
		OperationMode.NONE:
			operation_label.text = "Modo: Intercambio de filas"
			if selected_row_index == -1:
				operation_text.text = "Selecciona dos filas para intercambiar\n(‚Üë‚Üì para cambiar fila)"
			else:
				var selected_values = matrix_data[selected_row_index].values
				var selected_values_str = _format_values_array(selected_values)
				operation_text.text = "R%d = %s\nSelecciona otra fila para intercambiar\n(‚Üë‚Üì para cambiar fila)" % [selected_row_index + 1, selected_values_str]
		
		OperationMode.MULTIPLY:
			operation_label.text = "Modo: Multiplicaci√≥n"
			_update_scalar_operation_display("√ó")
		
		OperationMode.DIVIDE:
			operation_label.text = "Modo: Divisi√≥n"
			_update_scalar_operation_display("√∑")
		
		OperationMode.ADD_ROWS:
			operation_label.text = "Modo: Suma de filas"
			_update_add_rows_display()

func _format_values_array(values: Array) -> String:
	var values_str = ""
	for i in range(values.size()):
		var value = snapped(values[i], 0.01)
		if value == int(value):
			value = int(value)  # Mostrar enteros sin decimales
		values_str += str(value) + ", "
	values_str = values_str.trim_suffix(", ")
	return "[" + values_str + "]"

func _update_scalar_operation_display(symbol: String) -> void:
	if input_mode:
		var display_value = input_value if input_value.length() > 0 else "_"
		operation_text.text = "Fila %s %s\nIntroduce el valor y presiona ENTER\nESC para cancelar" % [symbol, display_value]
	elif selected_row_index == -1:
		operation_text.text = "Fila %s %.2f\nSelecciona una fila para ver la vista previa\n(‚Üë‚Üì para cambiar fila, + o - para ajustar, teclea un n√∫mero directamente o ENTER para confirmar)" % [symbol, scalar_value]
	else:
		var current_values = matrix_data[selected_row_index].values
		var current_values_str = _format_values_array(current_values)
		
		var values_str = ""
		if preview_active:
			var preview_values = _calculate_scalar_preview_values(current_values, symbol)
			values_str = _format_preview_values(preview_values)
		
		operation_text.text = "R%d %s %.2f\nActual: %s\n%s\n(‚Üë‚Üì para cambiar fila, + o - para ajustar, teclea un n√∫mero o ENTER para confirmar)" % [selected_row_index + 1, symbol, scalar_value, current_values_str, values_str]

func _update_add_rows_display() -> void:
	if input_mode:
		var display_value = input_value if input_value.length() > 0 else "_"
		operation_text.text = "Suma con factor: %s\nIntroduce el valor y presiona ENTER\nESC para cancelar" % display_value
	elif first_row_selected == -1:
		operation_text.text = "Selecciona la primera fila (fila origen)\n(‚Üë‚Üì para cambiar fila)"
	elif selected_row_index == -1 or selected_row_index == first_row_selected:
		var source_values = matrix_data[first_row_selected].values
		var source_values_str = _format_values_array(source_values)
		operation_text.text = "R? + %.2f√óR%d\nR%d = %s\nSelecciona la fila destino\n(‚Üë‚Üì para cambiar fila, + o - para ajustar el valor, teclea un n√∫mero directamente)" % [scalar_value, first_row_selected + 1, first_row_selected + 1, source_values_str]
	else:
		var target_values = matrix_data[selected_row_index].values
		var source_values = matrix_data[first_row_selected].values
		var target_values_str = _format_values_array(target_values)
		var source_values_str = _format_values_array(source_values)
		
		var values_str = ""
		if preview_active:
			var temp_values = target_values.duplicate()
			for i in range(temp_values.size()):
				temp_values[i] += source_values[i] * scalar_value
			values_str = _format_preview_values(temp_values)
		
		operation_text.text = "R%d + %.2f√óR%d\nR%d = %s\nR%d = %s\n%s\n(‚Üë‚Üì para cambiar fila, + o - para ajustar, teclea un n√∫mero o ENTER para confirmar)" % [selected_row_index + 1, scalar_value, first_row_selected + 1, selected_row_index + 1, target_values_str, first_row_selected + 1, source_values_str, values_str]

func _calculate_scalar_preview_values(row_values: Array, symbol: String) -> Array:
	var preview_values = []
	for value in row_values:
		if symbol == "√ó":
			preview_values.append(value * scalar_value)
		elif symbol == "√∑":
			preview_values.append(value / scalar_value)
	return preview_values

func _format_preview_values(values: Array) -> String:
	var values_str = ""
	for i in range(values.size()):
		var value = snapped(values[i], 0.01)
		if value == int(value):
			value = int(value)  # Mostrar enteros sin decimales
		values_str += str(value) + ", "
	values_str = values_str.trim_suffix(", ")
	return "‚Üí [" + values_str + "]"

func generate_matrix_ui():
	clear_matrix_container()
	matrix_container.add_theme_constant_override("separation", 10)
	selected_row_index = -1

	for row_index in matrix_data.size():
		var row_data = matrix_data[row_index]
		var row_color = row_data.color
		var row = MatrixRowScene.instantiate()
		row.row_index = row_index
		row.connect("row_selected", _on_row_selected)
		
		# N√∫mero de columnas total
		var total_columns = row_data.values.size()

		for col_index in total_columns:
			# Si es la √∫ltima columna, a√±adir un separador vertical antes
			if col_index == total_columns - 1:
				# Crear un separador vertical
				var separator = VSeparator.new()
				separator.custom_minimum_size = Vector2(6, 0)  # Ancho del separador
				separator.modulate = Color(1, 1, 1, 0.5)  # Color semitransparente
				# A√±adir algo de margen
				separator.add_theme_constant_override("separation", 15)
				row.add_child(separator)
			
			# Crear el bloque para el valor
			var value = row_data.values[col_index]
			var block = BlockScene.instantiate()
			block.set_value(value, row_color)
			block.row_index = row_index
			block.column_index = col_index
			block.connect("cell_clicked", _on_cell_clicked)
			
			# Si es la √∫ltima columna, aplicar un estilo diferente
			if col_index == total_columns - 1:
				block.add_theme_constant_override("margin_left", 10)  # A√±adir margen izquierdo
			
			row.add_child(block)

		matrix_container.add_child(row)

func clear_matrix_container():
	for child in matrix_container.get_children():
		child.queue_free()

func _on_cell_clicked(row: int, col: int):
	print("üñ±Ô∏è Celda clickeada en fila %d, columna %d" % [row, col])
	_on_row_selected(row)

func _on_row_selected(index: int) -> void:
	print("Seleccionaste la fila:", index)
	
	# Handle row selection internally based on current mode
	_handle_row_selection_internal(index)

func _handle_row_selection_internal(index: int) -> void:
	# Handle row selection based on current operation mode
	match current_mode:
		OperationMode.NONE:
			_handle_swap_row_selection(index)
		OperationMode.MULTIPLY:
			_handle_scalar_row_selection(index)
		OperationMode.DIVIDE:
			_handle_scalar_row_selection(index)
		OperationMode.ADD_ROWS:
			_handle_add_rows_selection(index)

func _handle_swap_row_selection(index: int) -> void:
	if selected_row_index == -1:
		# Primera fila seleccionada
		selected_row_index = index
		set_row_highlight(index, true)
		update_operation_display()
	elif selected_row_index == index:
		# Deseleccionar la misma fila
		set_row_highlight(index, false)
		selected_row_index = -1
		update_operation_display()
	else:
		# Segunda fila seleccionada - intercambiar
		var second_row = index
		swap_rows(selected_row_index, second_row)
		reset_operation_mode()

func _handle_scalar_row_selection(index: int) -> void:
	# Limpiar la selecci√≥n anterior si existe
	if selected_row_index >= 0:
		set_row_highlight(selected_row_index, false)
		clear_operation_preview()
	
	if selected_row_index == index:
		# Deseleccionar la misma fila
		selected_row_index = -1
	else:
		# Seleccionar nueva fila
		selected_row_index = index
		set_row_highlight(index, true)
		show_operation_preview()
	
	update_operation_display()

func _handle_add_rows_selection(index: int) -> void:
	if first_row_selected == -1:
		# Seleccionar la primera fila (origen)
		first_row_selected = index
		set_row_highlight(index, true)
		update_operation_display()
	elif first_row_selected == index:
		# Deseleccionar la fila origen
		set_row_highlight(index, false)
		first_row_selected = -1
		update_operation_display()
	else:
		# Limpiar la selecci√≥n anterior del destino si existe
		if selected_row_index >= 0 and selected_row_index != first_row_selected:
			set_row_highlight(selected_row_index, false)
			clear_operation_preview()
		
		if selected_row_index == index:
			# Deseleccionar la fila destino
			selected_row_index = -1
		else:
			# Seleccionar nueva fila destino
			selected_row_index = index
			set_row_highlight(index, true)
			show_operation_preview()
		
		update_operation_display()

func show_operation_preview() -> void:
	# Limpiar cualquier vista previa anterior
	clear_operation_preview()
	
	# Handle preview based on current operation mode
	match current_mode:
		OperationMode.MULTIPLY:
			_show_scalar_preview("√ó")
		OperationMode.DIVIDE:
			_show_scalar_preview("√∑")
		OperationMode.ADD_ROWS:
			_show_add_rows_preview()

func _show_scalar_preview(symbol: String) -> void:
	if selected_row_index >= 0:
		var current_values = matrix_data[selected_row_index].values
		var preview_values = _calculate_scalar_preview_values(current_values, symbol)
		
		preview_active = true
		update_preview_ui(selected_row_index, preview_values)

func _show_add_rows_preview() -> void:
	if selected_row_index >= 0 and first_row_selected >= 0 and selected_row_index != first_row_selected:
		var target_values = matrix_data[selected_row_index].values.duplicate()
		var source_values = matrix_data[first_row_selected].values
		
		# Calcular los nuevos valores
		for i in range(target_values.size()):
			target_values[i] += source_values[i] * scalar_value
		
		preview_active = true
		update_preview_ui(selected_row_index, target_values)

func apply_current_operation() -> void:
	# Limpiar cualquier vista previa antes de aplicar la operaci√≥n final
	clear_operation_preview()
	
	# Handle operation application based on current mode
	match current_mode:
		OperationMode.MULTIPLY:
			_apply_scalar_operation("multiply")
		OperationMode.DIVIDE:
			_apply_scalar_operation("divide")
		OperationMode.ADD_ROWS:
			_apply_add_rows_operation()

func _apply_scalar_operation(operation: String) -> void:
	if selected_row_index >= 0:
		match operation:
			"multiply":
				multiply_row(selected_row_index, scalar_value)
			"divide":
				divide_row(selected_row_index, scalar_value)

func _apply_add_rows_operation() -> void:
	if selected_row_index >= 0 and first_row_selected >= 0 and selected_row_index != first_row_selected:
		add_row_multiple(first_row_selected, selected_row_index, scalar_value)

func swap_rows(i: int, j: int):
	func swap_rows(i: int, j: int):
	# First, update the data structure immediately
	var temp = matrix_data[i]
	matrix_data[i] = matrix_data[j]
	matrix_data[j] = temp
	
	# Flash the rows that are being swapped
	flash_rows_and_update(i, j)
	
	# No animation needed - just update the UI instantly
	update_row_ui(i)
	update_row_ui(j)

# Removed the create_row_copy function as we're animating the original rows directly

func flash_rows_and_update(i: int, j: int):
	# Get the rows to flash
	var row_i = matrix_container.get_child(i)
	var row_j = matrix_container.get_child(j)
	
	# Simple flash effect to indicate the swap
	var flash_tween = create_tween()
	flash_tween.set_parallel(true)
	
	# Step 1: Highlight both rows
	flash_tween.tween_property(row_i, "modulate", Color(1.3, 1.3, 1.3, 1.0), 0.15)
	flash_tween.tween_property(row_j, "modulate", Color(1.3, 1.3, 1.3, 1.0), 0.15)
	
	# Step 2: Unhighlight both rows after a short delay
	flash_tween.tween_property(row_i, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.15).set_delay(0.15)
	flash_tween.tween_property(row_j, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.15).set_delay(0.15)

# Removed finish_row_swap as it's no longer needed with our simplified approach

func update_row_ui(index: int):
	var row = matrix_container.get_child(index)
	var row_data = matrix_data[index]
	var value_index = 0  # √çndice para rastrear los valores en row_data
	
	for j in range(row.get_child_count()):
		var cell = row.get_child(j)
		if cell.has_method("set_value"):
			# Reset any preview styling and restore original values
			cell.set_value(row_data.values[value_index], row_data.color)
			value_index += 1
			
		# Force reset modulate to stop any blinking animations
		if cell is Panel:
			cell.modulate = Color(1, 1, 1, 1)
	
	set_row_highlight(index, false)

func set_row_highlight(index: int, highlight: bool):
	if index < 0 or index >= matrix_container.get_child_count():
		return

	var row = matrix_container.get_child(index)
	for cell in row.get_children():
		if cell is Panel:
			var style := StyleBoxFlat.new()
			style.bg_color = Color(0.1, 0.1, 0.1)
			
			# Get the row color from matrix_data for consistent border coloring
			var row_color = matrix_data[index].color
			if highlight:
				style.border_color = row_color.lightened(0.5)
			else:
				style.border_color = row_color
			
			style.set_border_width_all(6)
			style.corner_radius_top_left = 6
			style.corner_radius_top_right = 6
			style.corner_radius_bottom_left = 6
			style.corner_radius_bottom_right = 6
			cell.add_theme_stylebox_override("panel", style)

			if highlight:
				var tween := create_tween()
				tween.tween_property(cell, "modulate", Color(1, 1, 1, 0.5), 0.15)
				tween.tween_property(cell, "modulate", Color(1, 1, 1, 1), 0.15)
			else:
				cell.modulate = Color(1, 1, 1, 1)

func add_history(text: String):
	var label = Label.new()
	label.text = text
	func add_history(text: String):
	var label = Label.new()
	label.text = text
	history_panel.add_child(label)

# Funciones para manejar la vista previa de operaciones
func clear_operation_preview() -> void:
	if preview_active:
		preview_active = false
		
		# Stop all active preview animations more aggressively
		for tween in active_preview_tweens:
			if tween != null and tween.is_valid():
				tween.kill()
		active_preview_tweens.clear()
		
		# Also stop any tweens that might be attached to matrix cells directly
		for i in range(matrix_container.get_child_count()):
			var row = matrix_container.get_child(i)
			for cell in row.get_children():
				if cell is Panel:
					# Reset modulate and stop any direct tweens on the cell
					cell.modulate = Color(1, 1, 1, 1)
		
		# Restaurar la visualizaci√≥n original de todas las filas afectadas
		if selected_row_index >= 0:
			update_row_ui(selected_row_index)
		# Tambi√©n restaurar cualquier otra fila que pudiera haber sido modificada
		if first_row_selected >= 0 and first_row_selected != selected_row_index:
			update_row_ui(first_row_selected)

func update_preview_ui(row_index: int, preview_values: Array) -> void:
	var row = matrix_container.get_child(row_index)
	var value_index = 0  # √çndice para rastrear los valores
	
	# Obtener el color original de la fila y hacer una versi√≥n fantasmal
	var original_row_color = matrix_data[row_index].color
	var preview_color = Color(0.7, 0.7, 0.9, 0.7)  # Color azul-gris transl√∫cido para el texto
	
	for j in range(row.get_child_count()):
		var cell = row.get_child(j)
		if cell.has_method("set_value"):
			# Usar un valor redondeado para mejor visualizaci√≥n
			var rounded_value = snapped(preview_values[value_index], 0.01)
			
			# Verificar si es un entero para mostrar sin decimales
			if rounded_value == int(rounded_value):
				rounded_value = int(rounded_value)
			
			cell.set_value(rounded_value, preview_color)
			
			# Crear un estilo fantasmal para la vista previa usando el color de la fila
			if cell is Panel:
				var style := StyleBoxFlat.new()
				style.bg_color = Color(0.05, 0.05, 0.1, 0.2)  # Fondo muy transl√∫cido
				
				# Usar el color original de la fila pero muy transparente para el borde
				var ghost_border_color = original_row_color
				ghost_border_color.a = 0.3  # Muy transparente
				style.border_color = ghost_border_color
				style.set_border_width_all(2)  # Borde muy delgado
				
				style.corner_radius_top_left = 4
				style.corner_radius_top_right = 4
				style.corner_radius_bottom_left = 4
				style.corner_radius_bottom_right = 4
				
				cell.add_theme_stylebox_override("panel", style)
				
				# Crear efecto de parpadeo fantasmal y guardar la referencia
				var blink_tween = create_tween()
				blink_tween.set_loops()  # Bucle infinito
				blink_tween.tween_property(cell, "modulate", Color(1.0, 1.0, 1.0, 0.3), 0.8)
				blink_tween.tween_property(cell, "modulate", Color(1.0, 1.0, 1.0, 0.7), 0.8)
				
				# Guardar la referencia del tween para poder detenerlo despu√©s
				active_preview_tweens.append(blink_tween)
			
			value_index += 1

# Funciones para realizar operaciones directamente en la matriz
func multiply_row(row_index: int, scalar: float) -> void:
	# Extraer los valores para operar con la clase Matrix
	var values_matrix = []
	for row in matrix_data:
		values_matrix.append(row.values.duplicate())
	
	# Usar la clase Matrix para multiplicar la fila
	Matrix.multiply_row(values_matrix, row_index, scalar)
	
	# Actualizar los valores en matrix_data
	matrix_data[row_index].values = values_matrix[row_index]
	
	# Actualizar UI
	update_row_ui(row_index)
	
	# A√±adir a historial
	add_history("R%d √ó %.1f" % [row_index + 1, scalar])
	
	# Restablecer el modo
	reset_operation_mode()

func divide_row(row_index: int, scalar: float) -> void:
	if scalar == 0:
		return  # Evitar divisi√≥n por cero
	
	# Para divisi√≥n, usamos multiply_row con 1/scalar
	multiply_row(row_index, 1.0/scalar)
	
	# Reemplazamos la entrada en el historial para mostrar divisi√≥n en lugar de multiplicaci√≥n
	var last_history = history_panel.get_child(history_panel.get_child_count() - 1)
	last_history.text = "R%d √∑ %.1f" % [row_index + 1, scalar]

func add_row_multiple(source_row: int, target_row: int, scalar: float) -> void:
	# Extraer los valores para operar con la clase Matrix
	var values_matrix = []
	for row in matrix_data:
		values_matrix.append(row.values.duplicate())
	
	# Usamos subtract_rows con un escalar negativo para hacer una suma
	Matrix.subtract_rows(values_matrix, source_row, target_row, -scalar)
	
	# Actualizar los valores en matrix_data
	matrix_data[target_row].values = values_matrix[target_row]
	
	# Actualizar UI
	update_row_ui(target_row)
	
	# A√±adir a historial
	add_history("R%d + %.1f√óR%d" % [target_row + 1, scalar, source_row + 1])
	
	# Restablecer el modo
	reset_operation_mode()
